const experimental_utils_1 = require("@typescript-eslint/experimental-utils");
const getFunction_1 = require("../utils/getFunction");
const load_1 = require("../utils/load");
const propertiesType_1 = require("../utils/propertiesType");
module.exports = {
    name: "no-navigational-load",
    meta: {
        type: "problem",
        messages: {
            navigationalLoad: "Calling load on the navigation property '{{loadValue}}' slows down your add-in.",
        },
        docs: {
            description: "Calling load on a navigation property causes unneeded data to load and slows down your add-in.",
            category: "Best Practices",
            recommended: false,
            url: "https://docs.microsoft.com/office/dev/add-ins/develop/application-specific-api-model#scalar-and-navigation-properties",
        },
        schema: [],
    },
    create: function (context) {
        function isLoadingValidPropeties(propertyName) {
            const properties = propertyName.split("/");
            const lastProperty = properties.pop();
            if (!lastProperty)
                return false;
            for (const property of properties) {
                if (propertiesType_1.getPropertyType(property) !== propertiesType_1.PropertyType.navigational) {
                    return false;
                }
            }
            return propertiesType_1.getPropertyType(lastProperty) === propertiesType_1.PropertyType.scalar;
        }
        function findNavigationalLoad(scope) {
            scope.variables.forEach((variable) => {
                let getFound = false;
                variable.references.forEach((reference) => {
                    var _a;
                    const node = reference.identifier;
                    if (reference.isWrite()) {
                        getFound = false; // In case of reassignment
                        if (reference.writeExpr && getFunction_1.isGetFunction(reference.writeExpr)) {
                            getFound = true;
                            return;
                        }
                    }
                    if (!getFound) {
                        // If reference was not related to a previous get
                        return;
                    }
                    if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === experimental_utils_1.TSESTree.AST_NODE_TYPES.MemberExpression &&
                        load_1.isLoadFunction(node.parent)) {
                        const propertyName = load_1.getLoadArgument(node.parent);
                        if (!isLoadingValidPropeties(propertyName)) {
                            context.report({
                                node: node.parent,
                                messageId: "navigationalLoad",
                                data: { name: node.name, loadValue: propertyName },
                            });
                        }
                    }
                });
            });
            scope.childScopes.forEach(findNavigationalLoad);
        }
        return {
            Program() {
                findNavigationalLoad(context.getScope());
            },
        };
    },
};
//# sourceMappingURL=no-navigational-load.js.map